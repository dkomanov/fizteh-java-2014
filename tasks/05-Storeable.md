## Storeable

Данные сложной структуры.

В хранилище в качестве значений могут использоваться не только строки, но и структруированные данные.
Значения организованы в виде упорядоченного списка со строгой типизацией. Типы элементов списка, их количество и порядок
известны заранее, на момент создания таблицы, и более не могут изменяться.

Поддерживаемые типы элементов - ```int, long, byte, float, double, boolean, String```.

### Контракт

Контракт изменён, необходимо реализовать интерфейсы из пакета structured:
[ru.fizteh.fivt.storage.structured](../src/ru/fizteh/fivt/storage/structured) (Table, TableProvider, TableProviderFactory).
Добавляется интерфейс Storeable.

Каждый метод каждого интерфейса должен быть покрыт модульными тестами (с помощью [JUnit](http://junit.org/)).
Для классов-реализаций интерфейсов, где это разумно, также должны быть написаны тесты.

### Предполагаемое использование.

Для сериализации и десериализации ```Storeable```, а также создания новых ```Storeable```,
используются соответствующие методы ```TableProvider```. Форматы сериализации и десериализации
задаются в соответствии с вариантом.

Внутренняя реализация также должна использовать именно эти методы. Разумно в объекте ```Table```
хранить ссылку на ```TableProvider```.

Storeable допускает null-значения элементов. Это нужно иметь ввиду при сериализации. Гарантируется,
что в сериализованных значениях не будет переводов строк. Тем не менее, там могут быть пробелы и символы табуляции.

### Форматы файлов

Типы данных содержатся в директории таблицы, в файле signature.tsv.
Формат - список типов столбцов. Названия типа точно как во введении в задачу. Разделены пробелами.

Формат файлов остаётся прежним. При записи значение Storeable необходимо сериализовать в строку с помощью метода
```TableProvider.serialize()```, а при чтении необходимо десериализовать строку с помощью метода ```TableProvider.deserialize()```.

### Изменения в командах:

#### create
Создать новую таблицу и зафиксировать на диске и в памяти ее сигнатуру.
```
create tablename (type1 type2 ... typeN)
```

#### Все команды
Если формат значения неправильный, или в значении фигурирует недопустимый символ, или неправильный тип колонки
(в т.ч. при создании таблицы), необходимо выводить на консоль сообщение (где на месте ```description``` необходимо
указать что именно не так; в этом описании не должно быть скобок и переносов строк):
```
wrong type (description)
```

При вводе и выводе значений через шелл нужно проводить такую же сериализацию и десериализацию,
как и при работе с файлами.

### Варианты

#### Вариант 1. XML

Сериализовать Storeable в XML вида:
```
<row><col> EL  1 </col><col>3</col><null/></row>
```
Заголовочный тег - ```<row>```, внутренний тег - ```<col>```. Для null специальный тег - ```null```.
Числа и boolean записываются с помощью ```Xxx.toString(n)```, считываются, соответственно, с помощью ```Xxx.parseXxx(s)```.

#### Вариант 2. JSON

Сериализовать Storeable в JSON вида:
```
[" EL  1 ", 3, null]
```
Поддержать синтаксис JSON, как есть. Гарантируется, что в сериализованной записи не будет перевода строки.

### Подводные камни

* Ко всем проверкам из предыдущих работ добавляется проверка валидности Storeable формата. Нужно учесть
  валидность синтаксиса формата сериализации, количество и тип элементов, валидность их значений.
* При работе со Storeable нужно постоянно проверять соответствие типов. Надо помнить, что Storeable
  поддерживают null-значения.
